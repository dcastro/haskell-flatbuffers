{- HLINT ignore "Avoid lambda" -}

module Compare where

import Control.Monad
import Criterion
import Data.ByteString qualified as BS
import Data.ByteString.Lazy qualified as BSL
import Data.Function ((&))
import Data.Functor ((<&>))
import Data.Int
import Data.Text (Text)
import Data.Text qualified as T
import Data.Vector qualified as V
import FlatBuffers.Examples.HandWritten3 qualified as W3P
import FlatBuffers.Internal.Write qualified as W1
import FlatBuffers.Internal.Write2 qualified as W2
import FlatBuffers.Internal.Write3 qualified as W3
import FlatBuffers.Internal.Write3Copy qualified as W3C

data Person = Person
  { personName :: Text
  , personAge :: Int32
  , personFriends :: V.Vector Text
  }

-- TODO: use different strings for names
mkPeople :: Int32 -> Int32 -> V.Vector Person
mkPeople peopleCount friendsCount =
  [1..peopleCount]
  <&> do \i -> Person "abcdefghijk" i $ mkFriends friendsCount
  & V.fromList

mkFriends :: Int32 -> V.Vector Text
mkFriends friendsCount =
  [1..friendsCount]
  <&> do \i -> T.pack $ show i
  & V.fromList

write1 :: V.Vector Person -> BSL.ByteString
write1 people =
  W1.encode do
    W1.writeTable
      [ W1.writeVectorTableTableField $ W1.fromMonoFoldable' $ people <&> \p ->
          W1.writeTable
            [
              W1.writeInt32TableField p.personAge
              ,
              W1.writeTextTableField p.personName
              ,
              W1.writeVectorTextTableField $ W1.fromMonoFoldable' p.personFriends
            ]
      ]

write2 :: V.Vector Person -> BS.ByteString
write2 people =
  W2.encode W2.defaultWriteSettings do

    peopleTables <- W2.writeMany people \person -> do
      name <- W2.writeText person.personName
      friends <- W2.fromFoldable =<< W2.writeMany person.personFriends W2.writeText
      W2.writeTable @Person 3 $ mconcat
        [
          W2.writeInt32TableField 0 person.personAge
          ,
          W2.writeOffsetTableField 1 name
          ,
          W2.writeOffsetTableField 2 friends
        ]

    peopleVector <- W2.fromFoldable peopleTables

    W2.writeTable 1 $ W2.writeOffsetTableField 0 peopleVector

write3 :: V.Vector Person -> BS.ByteString
write3 people =
  W3.encode W3.defaultWriteSettings do
    peopleTables <- W3.writeMany people \person -> do
      name <- W3.writeText person.personName
      friends <- W3.fromFoldable =<< W3.writeMany person.personFriends W3.writeText
      W3.writeTable @Person 3 $ mconcat
        [
          W3.writeInt32TableField 0 person.personAge
          ,
          W3.writeOffsetTableField 1 name
          ,
          W3.writeOffsetTableField 2 friends
        ]
    peopleVector <- W3.fromFoldable peopleTables

    W3.writeTable 1 $ W3.writeOffsetTableField 0 peopleVector

write3Copy :: V.Vector Person -> BS.ByteString
write3Copy people =
  W3C.encode W3C.defaultWriteSettings do
    peopleTables <- W3C.writeMany people \person -> do
      name <- W3C.writeText person.personName
      friends <- W3C.fromFoldable =<< W3C.writeMany person.personFriends W3C.writeText
      W3C.writeTable @Person 3 $ mconcat
        [
          W3C.writeInt32TableField 0 person.personAge
          ,
          W3C.writeOffsetTableField 1 name
          ,
          W3C.writeOffsetTableField 2 friends
        ]
    peopleVector <- W3C.fromFoldable peopleTables
    W3C.writeTable 1 $ W3C.writeOffsetTableField 0 peopleVector

-- Uses the same underlying code as `write3`, but goes through the public API generated by TH.
write3Public :: V.Vector Person -> BS.ByteString
write3Public people =
  W3.encode W3.defaultWriteSettings do
    peopleVector <- W3.fromFoldable =<< W3.writeMany people \person -> do
      name <- W3.writeText person.personName
      friends <- W3.fromFoldable =<< W3.writeMany person.personFriends W3.writeText
      W3P.person (Just person.personAge) (Just name) (Just friends)
    W3P.people (Just peopleVector)

groups :: [Benchmark]
groups =
  [ bgroup "People"
    [
    --   bench "Write1" $ nf write1 $ mkPeople peopleCount friendsCount
    -- ,
    --   bench "Write2" $ nf write2 $ mkPeople peopleCount friendsCount
    -- ,
    --   bench "Write3" $ nf write3 $ mkPeople peopleCount friendsCount
    -- ,
    --   bench "Write3Copy" $ nf write3Copy $ mkPeople peopleCount friendsCount
    -- ,
    --   bench "Write3Public" $ nf write3Public $ mkPeople peopleCount friendsCount
    ]
  , bgroup "Unions"
    [
      bench "writeWeapons1" $ nf writeWeapons1 $ mkWeapons unionCount
      ,
      bench "writeWeapons3" $ nf writeWeapons3 $ mkWeapons unionCount
      ,
      bench "writeWeapons3Public" $ nf writeWeapons3Public $ mkWeapons unionCount
    ]
  ]
  where
    peopleCount = 100000
    friendsCount = 1

    unionCount = 10000


----------------------------------------------------------------------------
-- Unions
----------------------------------------------------------------------------

data WeaponData
  = SwordData !Text
  | AxeData !Int32

mkWeapons :: Int32 -> V.Vector WeaponData
mkWeapons weaponCount =
  V.fromList $ [1..weaponCount] <&> \i ->
    if even i
      then SwordData "lajl1ij"
      else AxeData i

writeWeapons1 :: V.Vector WeaponData -> BSL.ByteString
writeWeapons1 weapons = do
  W1.encode do
    let vec = W1.fromMonoFoldable' $ weapons <&> \case
          SwordData str ->
            W1.writeUnion 1 $ W1.writeTable [ W1.writeTextTableField str ]
          AxeData int ->
            W1.writeUnion 2 $ W1.writeTable [ W1.writeInt32TableField int ]
    W1.writeTable
      [ W1.writeUnionTypesVectorTableField vec
      , W1.writeUnionValuesVectorTableField vec
      ]

writeWeapons3 :: V.Vector WeaponData -> BS.ByteString
writeWeapons3 weapons = do
  W3.encode W3.defaultWriteSettings do

    (unionLocs, unionTypes) <- W3.writeMany2 weapons \case
      SwordData str -> do
        text <- W3.writeText str
        tableLoc <- W3.writeTable 1 $ W3.writeOffsetTableField 0 text
        pure $ W3.UnionLocation 1 tableLoc
      AxeData int -> do
        tableLoc <- W3.writeTable 1 $ W3.writeInt32TableField 0 int
        pure $ W3.UnionLocation 2 tableLoc

    unionLocsVec <- W3.fromFoldable unionLocs
    unionTypesVec <- W3.fromFoldable unionTypes

    W3.writeTable 2 $ mconcat
      [ W3.writeOffsetTableField 0 unionTypesVec
      , W3.writeOffsetTableField 1 unionLocsVec
      ]

writeWeapons3Public :: V.Vector WeaponData -> BS.ByteString
writeWeapons3Public weaponData =
  W3.encode W3.defaultWriteSettings do

    (weapons, weaponTypes) <- W3.writeMany2 weaponData \case
      SwordData str -> do
        str <- W3.writeText str
        W3P.weaponSword <$> W3P.sword (Just str)
      AxeData int -> do
        W3P.weaponAxe <$> W3P.axe (Just int)

    weaponVector <- W3.fromFoldable weapons
    weaponTypesVector <- W3.fromFoldable weaponTypes

    W3P.weapons (Just (weaponVector, weaponTypesVector))
